<!DOCTYPE html>
<html lang="de">
<head>
    <meta charset="UTF-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0"/>
    <title>Bustrinker</title>
    <link rel="icon" href="icon.jpeg" type="image/jpeg">
    <link rel="sitemap" type="application/xml" title="Sitemap" href="sitemap.xml">
    <link rel="preconnect" href="https://fonts.googleapis.com">
    <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
    <link href="https://fonts.googleapis.com/css2?family=Orbitron:wght@400;700&family=Roboto:wght@300;400;700&display=swap" rel="stylesheet">
    <style>
        :root {
            --primary-glow: #00ffff;
            --secondary-glow: #ff00ff;
            --danger-glow: #ff4d4d;
            --success-glow: #4dff4d;
            --warning-glow: #ffc107;
            --dark-bg: #0a0f1a;
            --dark-bg-translucent: rgba(10, 20, 40, 0.75);
            --light-text: #e0e0e0;
            --highlight-text: #ffffff;
            --border-color: rgba(0, 255, 255, 0.3);
        }

        body {
            font-family: 'Roboto', -apple-system, BlinkMacSystemFont, "Segoe UI", Helvetica, Arial, sans-serif;
            background: var(--dark-bg) url('data:image/svg+xml,%3Csvg width="40" height="40" viewBox="0 0 40 40" xmlns="http://www.w3.org/2000/svg"%3E%3Cg fill="%230f1a2e" fill-opacity="0.4" fill-rule="evenodd"%3E%3Cpath d="M0 38.59l2.83-2.83 1.41 1.41L1.41 40H0v-1.41zM0 1.4l2.83 2.83 1.41-1.41L1.41 0H0v1.41zM38.59 40l-2.83-2.83 1.41-1.41L40 38.59V40h-1.41zM40 1.41l-2.83 2.83-1.41-1.41L38.59 0H40v1.41zM20 18.6l2.83-2.83 1.41 1.41L21.41 20l2.83 2.83-1.41 1.41L20 21.41l-2.83 2.83-1.41-1.41L18.59 20l-2.83-2.83 1.41-1.41L20 18.59z"/%3E%3C/g%3E%3C/svg%3E');
            color: var(--light-text);
            display: flex;
            justify-content: center;
            align-items: center;
            min-height: 100vh;
            margin: 0;
            padding: 20px 0;
            overflow-x: hidden;
        }
        .container {
            background: var(--dark-bg-translucent);
            padding: 30px 40px;
            border-radius: 12px;
            border: 1px solid var(--border-color);
            box-shadow: 0 0 25px rgba(0, 255, 255, 0.2), inset 0 0 10px rgba(0, 255, 255, 0.1);
            width: 100%;
            max-width: 560px;
            text-align: center;
            backdrop-filter: blur(10px);
            -webkit-backdrop-filter: blur(10px);
            transition: all 0.3s ease;
        }
        .screen { display: none; animation: fadeIn 0.5s ease-in-out; }
        .screen.active { display: block; }
        @keyframes fadeIn { from { opacity: 0; transform: translateY(10px); } to { opacity: 1; transform: translateY(0); } }

        h1, h2, h3 {
            font-family: 'Orbitron', sans-serif;
            color: var(--primary-glow);
            margin-top: 0;
            margin-bottom: 20px;
            text-shadow: 0 0 8px rgba(0, 255, 255, 0.7);
            letter-spacing: 1px;
        }
        hr { border: 0; height: 1px; background: var(--border-color); margin: 25px 0; }

        input[type=text] {
            width: calc(100% - 24px);
            padding: 12px;
            margin-bottom: 15px;
            border: 1px solid var(--border-color);
            border-radius: 6px;
            font-size: 16px;
            background: rgba(0, 20, 30, 0.5);
            color: var(--light-text);
            transition: all 0.3s ease;
        }
        input[type=text]::placeholder { color: #88aaff; opacity: 0.6; }
        input[type=text]:focus {
            outline: none;
            border-color: var(--primary-glow);
            box-shadow: 0 0 10px rgba(0, 255, 255, 0.5);
        }

        button {
            background: transparent;
            color: var(--primary-glow);
            border: 1px solid var(--primary-glow);
            padding: 12px 20px;
            border-radius: 6px;
            font-size: 16px;
            font-weight: 700;
            cursor: pointer;
            width: 100%;
            margin-bottom: 10px;
            transition: all 0.3s ease;
            text-transform: uppercase;
            letter-spacing: 1px;
            box-shadow: 0 0 5px rgba(0, 255, 255, 0.3), inset 0 0 5px rgba(0, 255, 255, 0.2);
        }
        button:hover { background: rgba(0, 255, 255, 0.15); box-shadow: 0 0 15px rgba(0, 255, 255, 0.7); }
        button:disabled {
            color: #558888;
            border-color: #558888;
            background: transparent;
            cursor: not-allowed;
            box-shadow: none;
        }
        .secondary-button {
            color: var(--secondary-glow);
            border-color: var(--secondary-glow);
            box-shadow: 0 0 5px rgba(255, 0, 255, 0.3), inset 0 0 5px rgba(255, 0, 255, 0.2);
        }
        .secondary-button:hover { background: rgba(255, 0, 255, 0.15); box-shadow: 0 0 15px rgba(255, 0, 255, 0.7); }
        
        .warning-button {
            color: var(--warning-glow);
            border-color: var(--warning-glow);
            box-shadow: 0 0 5px rgba(255, 193, 7, 0.3), inset 0 0 5px rgba(255, 193, 7, 0.2);
        }
        .warning-button:hover {
            background: rgba(255, 193, 7, 0.15);
            box-shadow: 0 0 15px rgba(255, 193, 7, 0.7);
        }

        ul { list-style: none; padding: 0; text-align: left; margin-top: 20px; border-top: 1px solid var(--border-color); }
        li { padding: 12px; border-bottom: 1px solid var(--border-color); font-size: 16px; transition: background-color 0.3s; }
        li:hover { background-color: rgba(0, 255, 255, 0.05); }
        li strong { font-weight: 700; color: var(--highlight-text); }

        .room-code, .display-code {
            font-family: 'Orbitron', sans-serif;
            font-size: 32px;
            font-weight: 700;
            padding: 15px;
            border-radius: 6px;
            margin: 15px 0;
            letter-spacing: 4px;
        }
        .room-code { color: var(--success-glow); background: rgba(77, 255, 77, 0.1); border: 1px solid rgba(77, 255, 77, 0.5); text-shadow: 0 0 8px var(--success-glow); }
        .display-code { color: var(--warning-glow); background: rgba(255, 193, 7, 0.1); border: 1px solid rgba(255, 193, 7, 0.5); text-shadow: 0 0 8px var(--warning-glow); }

        .settings-form, .game-section {
            text-align: left;
            margin-top: 20px;
            padding: 20px;
            border: 1px solid var(--border-color);
            border-radius: 8px;
            background: rgba(0, 30, 40, 0.4);
        }
        .settings-form label { display: block; margin-bottom: 15px; font-weight: 700; }
        .settings-form select, .card-assignment-row select {
            width: 100%;
            padding: 10px;
            border-radius: 4px;
            background: rgba(0, 20, 30, 0.8);
            border: 1px solid var(--border-color);
            color: var(--light-text);
            font-size: 16px;
        }
        .checkbox-label { display: flex; align-items: center; margin-top: 15px; }
        .checkbox-label input { width: auto; margin-right: 10px; accent-color: var(--primary-glow); }

        #my-hand { background: rgba(0, 50, 80, 0.4); }
        #received-cards { background: rgba(0, 80, 50, 0.4); }
        #public-info, #display-content { background: rgba(20, 30, 50, 0.4); }
        #give-card-controls { background: rgba(80, 60, 0, 0.4); border: 1px solid var(--warning-glow); }

        /* ---- Futuristic Card Styling ---- */
        .card {
            display: inline-block;
            width: 60px;
            height: 90px;
            border-radius: 6px;
            margin: 4px;
            vertical-align: middle;
            position: relative;
            overflow: hidden;
            background: #081018;
            border: 1px solid rgba(0, 255, 255, 0.3);
            box-shadow: 0 0 5px rgba(0, 255, 255, 0.2);
            transition: transform 0.3s ease, box-shadow 0.3s ease;
        }
        .card.interactive:not(.revealed):hover {
            transform: scale(1.05) translateY(-5px);
            box-shadow: 0 0 15px var(--primary-glow);
        }
        .card.interactive:not(.revealed) { cursor: pointer; }

        .card.back {
            background: linear-gradient(135deg, #0a1828 25%, transparent 25%) -50px 0, linear-gradient(225deg, #0a1828 25%, transparent 25%) -50px 0, linear-gradient(315deg, #0a1828 25%, transparent 25%), linear-gradient(45deg, #0a1828 25%, transparent 25%);
            background-size: 10px 10px;
            background-color: #001d3a;
            border: 1px solid var(--primary-glow);
        }

        .card-face {
            position: absolute;
            inset: 0;
            padding: 5px;
            border-radius: 6px;
        }
        .card--red  { color: var(--danger-glow); text-shadow: 0 0 5px var(--danger-glow); }
        .card--black{ color: var(--primary-glow); text-shadow: 0 0 5px var(--primary-glow); }

        .card-corner {
            position: absolute;
            display: flex;
            flex-direction: column;
            align-items: center;
            line-height: 1;
            font-weight: 700;
            font-family: 'Orbitron', sans-serif;
        }
        .card-corner.tl { top: 5px; left: 5px; }
        .card-corner.br { bottom: 5px; right: 5px; transform: rotate(180deg); }
        .card-rank { font-size: 16px; }
        .card-suit { font-size: 12px; }

        .card-center-suit {
            position: absolute;
            left: 50%;
            top: 50%;
            transform: translate(-50%, -50%);
            font-size: 40px;
            opacity: .2;
        }
        .card-center-suit.is-face {
            font-size: 48px;
            opacity: .8;
            font-family: 'Orbitron', sans-serif;
        }

        .pyramid-row { display: flex; justify-content: center; height: 95px; }
        .card-assignment-row { display: flex; align-items: center; justify-content: space-between; padding: 8px 0; border-bottom: 1px solid rgba(255, 193, 7, 0.3); }
        .card-assignment-row:last-child { border-bottom: none; }
        .card-assignment-row .card { margin: 0; width: 40px; height: 60px; }
        .card-assignment-row select { width: 60%; padding: 6px; border-radius: 4px; }

        @keyframes highlight {
            0% { transform: scale(1); box-shadow: 0 0 15px rgba(77, 255, 77, 0.3); }
            50% { transform: scale(1.08); box-shadow: 0 0 30px var(--success-glow); }
            100% { transform: scale(1); box-shadow: 0 0 15px rgba(77, 255, 77, 0.3); }
        }
        .highlight-animation { animation: highlight 1.5s ease-in-out; }

        .overlay {
            position: fixed; top: 0; left: 0; right: 0; bottom: 0;
            background: rgba(0, 0, 0, 0.85);
            display: flex; justify-content: center; align-items: center;
            z-index: 1000;
            backdrop-filter: blur(5px);
        }
        .overlay-content {
            background: var(--dark-bg-translucent);
            padding: 30px 40px;
            border-radius: 10px;
            text-align: center;
            border: 1px solid var(--success-glow);
            box-shadow: 0 0 25px rgba(77, 255, 77, 0.5);
        }
        .overlay-content h2 { color: var(--success-glow); text-shadow: 0 0 8px var(--success-glow); }
        .overlay-content button {
            margin-top: 20px; width: auto; padding: 10px 30px;
            color: var(--success-glow); border-color: var(--success-glow);
            box-shadow: 0 0 5px rgba(77, 255, 77, 0.3), inset 0 0 5px rgba(77, 255, 77, 0.2);
        }
        .overlay-content button:hover { background: rgba(77, 255, 77, 0.15); box-shadow: 0 0 15px rgba(77, 255, 77, 0.7); }

        .trigger-badge {
            display: inline-block;
            padding: 8px 12px;
            border-radius: 6px;
            background: rgba(0, 255, 255, 0.1);
            color: var(--primary-glow);
            font-weight: 700;
            margin-left: 10px;
            border: 1px solid var(--border-color);
            font-family: 'Orbitron', sans-serif;
        }
        .muted { color: #88aaff; font-size: 14px; margin-top: 10px; opacity: 0.8; }
    </style>
</head>
<body>
<div class="container">
    <!-- Screen 1: Home -->
    <div id="home-screen" class="screen active">
        <h1>BusTrinker</h1>
        <input type="text" id="nickname-input" placeholder="Dein Nickname">
        <button onclick="hostGame()">Spiel hosten</button>
        <hr>
        <input type="text" id="room-code-input" placeholder="Raum-Code" style="text-transform:uppercase">
        <button class="secondary-button" onclick="joinGame()">Spiel beitreten</button>
        <hr>
        <input type="text" id="display-code-input" placeholder="Display-Code">
        <button class="warning-button" onclick="joinAsDisplay()">Als Display beitreten</button>
        <button class="warning-button" style="margin-top: 20px;" onclick="window.open('rules.html', '_blank');">Regeln & Anleitung</button>
    </div>

    <!-- Screen 2: Lobby -->
    <div id="lobby-screen" class="screen">
        <h2>Lobby</h2>
        <p>Raum-Code:</p><div class="room-code" id="room-code-display"></div>
        <p><strong id="player-count">0</strong>/10 Spieler:</p><ul id="player-list"></ul>
        <div id="host-controls" style="display:none">
            <div class="settings-form">
                <label>Kartenanzahl:
                    <select id="card-count-select" onchange="updateSettings()">
                        <option value="32">32</option>
                        <option value="52">52</option>
                    </select>
                </label>
                <label>Anzahl Reihen:
                    <select id="row-count-select" onchange="updateSettings()">
                        <option value="3">3</option><option value="4">4</option>
                        <option value="5">5</option><option value="6">6</option>
                        <option value="7">7</option><option value="8">8</option>
                    </select>
                </label>
                <label class="checkbox-label"><input type="checkbox" id="external-display-checkbox" onchange="updateSettings()"> Externes Display?</label>
            </div>
            <div id="display-code-area" style="display:none">
                <p>Display-Code:</p><div class="display-code" id="display-code-display"></div>
            </div>
            <button id="start-game-button" onclick="startGame()" disabled>Spiel starten</button>
        </div>
        <div id="player-wait-message" style="display:none">
            <p>Warte, bis der Host startet...</p>
            <div id="player-settings-display"></div>
        </div>
    </div>

    <!-- Screen 3: Game (für Spieler) -->
    <div id="game-screen" class="screen">
        <h1>Spiel läuft!</h1>
        <div id="host-game-controls" style="display:none">
            <button id="reveal-pyramid-card-button" onclick="revealNextPyramidCardByHost()">Pyramiden-Karte aufdecken</button>
            <button id="reveal-discard-card-button" onclick="revealNextDiscardCard()">Reststapel-Karte aufdecken</button>
            <div class="muted" id="host-wait-hint" style="display:none">Warten auf Abgaben/Bestätigungen…</div>
        </div>
        <div id="public-info" class="game-section">
            <h3>Pyramide</h3><div id="pyramid-area-player"></div>
            <h3>Aufgedeckte Restkarten</h3><div id="public-revealed-cards">Keine</div>
            <p class="muted">Aktiver Wert:<span id="active-trigger-player" class="trigger-badge">–</span></p>
        </div>
        <div id="my-hand" class="game-section">
            <h3>Deine Handkarten</h3><div id="hand-cards-display"></div>
        </div>
        <div id="received-cards" class="game-section" style="display:none">
            <h3>Erhaltene Karten</h3><div id="received-cards-display"></div>
        </div>
        <div id="give-card-controls" style="display:none">
            <p><strong>Aktion!</strong> Weise jede deiner Karten mit dem aktiven Wert einem Spieler zu.</p>
            <div id="card-assignment-area"></div>
            <button onclick="giveCard()">Ausgewählte Karten abgeben</button>
            <div class="muted">Weiter geht’s erst, wenn alle Pflicht-Geber abgegeben haben und alle Empfänger bestätigt haben.</div>
        </div>
        <hr>
        <p>Spieler (Score):</p><ul id="game-player-list"></ul>
    </div>

    <!-- Screen 4: Display (für externes Gerät) -->
    <div id="display-screen" class="screen">
        <h1>Externes Display</h1>
        <div id="display-content" class="game-section">
            <h3>Pyramide</h3><div id="pyramid-area-display"></div>
            <hr><h3>Aufgedeckte Restkarten</h3><div id="display-revealed-cards"></div>
            <p class="muted">Aktiver Wert:<span id="active-trigger-display" class="trigger-badge">–</span></p>
        </div>
    </div>
</div>

<!-- Overlay für Kartenbestätigung -->
<div id="card-received-overlay" class="overlay" style="display:none">
    <div class="overlay-content">
        <h2>Karten erhalten!</h2>
        <p>Du hast <strong id="received-card-value"></strong> erhalten.</p>
        <button onclick="confirmReceivedCard()">Bestätigen</button>
    </div>
</div>


<script src="https://www.gstatic.com/firebasejs/8.10.1/firebase-app.js"></script>
<script src="https://www.gstatic.com/firebasejs/8.10.1/firebase-firestore.js"></script>
<script src="config.js"></script>
<script>
/* ================== CONFIG & GLOBALS ================== */
#const firebaseConfig = { apiKey:"AIzaSyAw5zRVmbvHGJUFKV0LGthGWsE4EqPN-Bw", authDomain:"bust-42c39.firebaseapp.com", projectId:"bust-42c39" };
#if (!firebase.apps.length) firebase.initializeApp(firebaseConfig);
#const db = firebase.firestore();

let myNickname = '', currentRoomCode = '', isHost = false;
let unsubscribeRoom, unsubscribeMyHand;
let currentPlayersInGame = [];
let playerIsDisplay = false;

const SVG_SPRITE_URL = 'https://upload.wikimedia.org/wikipedia/commons/c/c9/SVG-cards-1.3-French-style.svg';
const RANK_MAP = { 'a': 'A', 'b': 'K', 'c': 'Q', 'd': 'J', 'e': '10', 'f': '9', 'g': '8', 'h': '7', 'i': '6', 'j': '5', 'k': '4', 'l': '3', 'm': '2' };
const SUIT_MAP_NUM = { '1': 'H', '2': 'D', '3': 'S', '4': 'C' }; // 1=Herz, 2=Karo, 3=Pik, 4=Kreuz
const RANK_TEXT = { 'a': 'Ass', 'b': 'König', 'c': 'Dame', 'd': 'Bube', 'e': '10', 'f': '9', 'g': '8', 'h': '7', 'i': '6', 'j': '5', 'k': '4', 'l': '3', 'm': '2' };
const SUIT_TEXT = { '1': 'Herz', '2': 'Karo', '3': 'Pik', '4': 'Kreuz' };
function suitSymbolByNum(suitNum){
  // 1=Herz ♥, 2=Karo ♦, 3=Pik ♠, 4=Kreuz ♣
  switch(String(suitNum)){
    case '1': return '♥';
    case '2': return '♦';
    case '3': return '♠';
    case '4': return '♣';
    default : return '?';
  }
}
function suitColorClass(suitNum){
  return (String(suitNum)==='1' || String(suitNum)==='2') ? 'card--red' : 'card--black';
}

/* ================== UTIL ================== */
function showScreen(id){ document.querySelectorAll('.screen').forEach(s=>s.classList.remove('active')); document.getElementById(id).classList.add('active'); }
function generateCode(len,isNumeric=false){ const c=isNumeric?'0123456789':'ABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789'; let r=''; for(let i=0;i<len;i++) r+=c.charAt(Math.floor(Math.random()*c.length)); return r; }

function generateAlphanumericDeck(cardCount){
    const deck=[];
    const ranks = (cardCount===32) ? 'abcdefgh' : 'abcdefghijklm';
    for(const rank of ranks){
        for(let suit=1; suit<=4; suit++) {
            deck.push(rank + suit);
        }
    }
    return deck;
}

function getTotalRows(pyramidData) { let r = 0, total = 0; while (total < pyramidData.length) { r++; total += r; } return r; }

function getCardSvgId(cardValue) {
    const rankChar = cardValue.charAt(0);
    const suitNum = cardValue.substring(1);
    const svgRank = RANK_MAP[rankChar];
    const svgSuit = SUIT_MAP_NUM[suitNum];
    if (!svgRank || !svgSuit) return 'FR-back-blue-2';
    return `FR-${svgSuit}-${svgRank}`;
}

function cardValueToText(cardValue) {
    const rankChar = cardValue.charAt(0);
    const suitNum = cardValue.substring(1);
    return `${SUIT_TEXT[suitNum]} ${RANK_TEXT[rankChar]}`;
}

function createCardElement(cardValue, isHidden = false) {
  const cardEl = document.createElement('div');
  cardEl.className = 'card';
  if (cardValue) cardEl.dataset.value = cardValue;

  if (isHidden) {
    cardEl.classList.add('back');
    return cardEl;
  }

  const rankChar = String(cardValue||'').charAt(0);
  const suitNum  = String(cardValue||'').substring(1);
  const rankDisp = RANK_MAP[rankChar] || '?';
  const suitSym  = suitSymbolByNum(suitNum);
  const colorCls = suitColorClass(suitNum);
  const isFaceCard = /^(J|Q|K)$/.test(rankDisp);

  const face = document.createElement('div');
  face.className = `card-face ${colorCls}`;
  face.innerHTML = `
    <div class="card-corner tl">
      <div class="card-rank">${rankDisp}</div>
      <div class="card-suit">${suitSym}</div>
    </div>
    <div class="card-corner br">
      <div class="card-rank">${rankDisp}</div>
      <div class="card-suit">${suitSym}</div>
    </div>
    <div class="card-center-suit ${isFaceCard ? 'is-face' : ''}">
      ${isFaceCard ? rankDisp : suitSym}
    </div>
  `;
  cardEl.appendChild(face);
  return cardEl;
}


/* ================== LOBBY ================== */
async function hostGame(){
  window.open('https://otieu.com/4/9969336', '_blank');
  myNickname = document.getElementById('nickname-input').value.trim();
  if(!myNickname){ alert('Bitte gib einen Nickname ein.'); return; }
  isHost = true; playerIsDisplay=false; currentRoomCode = generateCode(6);
  const roomRef = db.collection('rooms').doc(currentRoomCode);
  try{
    await roomRef.set({ host: myNickname, status:'lobby', settings:{cardCount:32,rowCount:3}, externalDisplayEnabled:false, displayCode:null });
    await roomRef.collection('players').doc(myNickname).set({ joinedAt: firebase.firestore.FieldValue.serverTimestamp(), receivedCards: [], lastReceived: [], actionConfirmed: true, score: 0 });
    setupLobbyListeners(currentRoomCode);
    showScreen('lobby-screen');
    document.getElementById('room-code-display').innerText = currentRoomCode;
    document.getElementById('host-controls').style.display = 'block';
  }catch(e){ console.error(e); alert('Spiel konnte nicht gehostet werden.'); }
}

async function joinGame(){
  myNickname = document.getElementById('nickname-input').value.trim();
  const roomCode = document.getElementById('room-code-input').value.trim().toUpperCase();
  if(!myNickname || !roomCode){ alert('Nickname und Raum-Code sind erforderlich.'); return; }
  isHost=false; playerIsDisplay=false; currentRoomCode=roomCode;
  const roomRef = db.collection('rooms').doc(currentRoomCode);
  try{
    const roomDoc = await roomRef.get();
    if(!roomDoc.exists) throw new Error('Raum existiert nicht.');
    if(roomDoc.data().status!=='lobby') throw new Error('Spiel hat bereits begonnen.');
    const playersSnapshot = await roomRef.collection('players').get();
    if(playersSnapshot.docs.some(d=>d.id===myNickname)) throw new Error('Nickname bereits vergeben.');
    if(playersSnapshot.size>=10) throw new Error('Raum ist voll.');
    await roomRef.collection('players').doc(myNickname).set({ joinedAt: firebase.firestore.FieldValue.serverTimestamp(), receivedCards: [], lastReceived: [], actionConfirmed: true, score: 0 });
    setupLobbyListeners(currentRoomCode);
    showScreen('lobby-screen');
    document.getElementById('room-code-display').innerText = currentRoomCode;
    document.getElementById('player-wait-message').style.display='block';
  }catch(e){ console.error(e); alert('Beitreten fehlgeschlagen: '+e.message); }
}

async function joinAsDisplay(){
  const displayCode = document.getElementById('display-code-input').value.trim();
  if(!displayCode){ alert('Bitte gib einen Display-Code ein.'); return; }
  isHost=false; playerIsDisplay=true;
  try{
    const snap = await db.collection('rooms').where('displayCode','==',displayCode).limit(1).get();
    if(snap.empty) throw new Error('Kein Raum mit diesem Code gefunden.');
    currentRoomCode = snap.docs[0].id;
    showScreen('display-screen');
    setupDisplayListeners(currentRoomCode);
  }catch(e){ console.error(e); alert('Beitritt als Display fehlgeschlagen.'); }
}

function updateSettings(){
  if(!isHost) return;
  const roomRef = db.collection('rooms').doc(currentRoomCode);
  roomRef.get().then(doc=>{
    const currentDisplayCode = doc.data().displayCode;
    const updates = {
      'settings.cardCount': parseInt(document.getElementById('card-count-select').value,10),
      'settings.rowCount': parseInt(document.getElementById('row-count-select').value,10),
      'externalDisplayEnabled': document.getElementById('external-display-checkbox').checked
    };
    if(updates.externalDisplayEnabled && !currentDisplayCode) updates.displayCode = generateCode(4,true);
    else if(!updates.externalDisplayEnabled) updates.displayCode = null;
    roomRef.update(updates);
  });
}

/* ================== GAME START/STATE ================== */
async function startGame(){
  if(!isHost) return;
  const roomRef = db.collection('rooms').doc(currentRoomCode);
  const playersRef = roomRef.collection('players');
  try{
    const playersSnapshot = await playersRef.get();
    const players = playersSnapshot.docs.map(doc=>doc.id);
    if(players.length<2){ alert('Mindestens 2 Spieler werden benötigt.'); return; }
    await db.runTransaction(async (t)=>{
      const roomDoc = await t.get(roomRef);
      if(!roomDoc.exists || roomDoc.data().status!=='lobby') return;
      const {cardCount,rowCount} = roomDoc.data().settings;
      let deck = generateAlphanumericDeck(cardCount);
      deck = deck.sort(()=>Math.random()-0.5);
      const pyramidCardCount = (rowCount*(rowCount+1))/2;
      if(pyramidCardCount>=deck.length) throw new Error(`Zu viele Reihen (${rowCount}) für Kartenanzahl (${cardCount}).`);
      const pyramid = deck.splice(0,pyramidCardCount).map(card=>({cardValue:card,isRevealed:false}));
      const cardsPerPlayer = Math.floor(deck.length/players.length);
      const playerHands = {};
      players.forEach(n=>playerHands[n]=deck.splice(0,cardsPerPlayer));
      const discardPile = deck;
      t.update(roomRef,{ status:'in-game', gameState:{ pyramid, discardPile, revealedDiscard:[], currentTrigger:null, currentRow:null, currentPoints:null, requiredGivers:[], giversDone:[] } });
      for(const n of players) t.update(playersRef.doc(n),{ hand: playerHands[n], actionConfirmed:true, score: (roomDoc.get(`players.${n}.score`)||0) });
    });
  }catch(e){ console.error(e); alert('Spiel konnte nicht gestartet werden: '+e.message); }
}

async function revealPyramidCard(index){
  const roomRef = db.collection('rooms').doc(currentRoomCode);
  let triggerCard=null;
  await db.runTransaction(async (t)=>{
    const doc = await t.get(roomRef);
    const gs = doc.data().gameState;
    if(gs.pyramid[index] && !gs.pyramid[index].isRevealed){
      gs.pyramid[index].isRevealed = true;
      triggerCard = gs.pyramid[index].cardValue;
      
      const totalRows = getTotalRows(gs.pyramid);
      const triggerRowFromTop = indexToRow(gs.pyramid, index);
      const points = totalRows - triggerRowFromTop + 1;

      gs.currentTrigger = triggerCard;
      gs.currentRow = triggerRowFromTop;
      gs.currentPoints = points;
      gs.giversDone = [];
      gs.requiredGivers = [];
      t.update(roomRef,{ gameState: gs });
    }
  });
  if(triggerCard){
    await awardRowPointsOnReveal(triggerCard);
    await computeRequiredGivers(triggerCard);
  }
}

async function revealNextPyramidCardByHost(){
  const roomRef = db.collection('rooms').doc(currentRoomCode);
  let triggerCard=null;
  await db.runTransaction(async (t)=>{
    const doc = await t.get(roomRef);
    const gs = doc.data().gameState;
    const next = gs.pyramid.map(c => c.isRevealed).lastIndexOf(false);
    if(next!==-1){
      gs.pyramid[next].isRevealed = true;
      triggerCard = gs.pyramid[next].cardValue;

      const totalRows = getTotalRows(gs.pyramid);
      const triggerRowFromTop = indexToRow(gs.pyramid, next);
      const points = totalRows - triggerRowFromTop + 1;

      gs.currentTrigger = triggerCard;
      gs.currentRow = triggerRowFromTop;
      gs.currentPoints = points;
      gs.giversDone = [];
      gs.requiredGivers = [];
      t.update(roomRef,{ gameState: gs });
    }
  });
  if(triggerCard){
    await awardRowPointsOnReveal(triggerCard);
    await computeRequiredGivers(triggerCard);
  }
}

async function revealNextDiscardCard(){
  if(!isHost) return;
  const roomRef = db.collection('rooms').doc(currentRoomCode);
  const playersRef = roomRef.collection('players');
  try{
    const playersSnapshot = await playersRef.get();
    const allConfirmed = playersSnapshot.docs.every(d=>d.data().actionConfirmed);
    const roomDoc = await roomRef.get();
    const gs = roomDoc.data().gameState||{};
    const requiredGivers = gs.requiredGivers||[];
    const giversDone = gs.giversDone||[];
    const allGiversDone = requiredGivers.every(n=>giversDone.includes(n));
    if(!allConfirmed || !allGiversDone){ alert('Warten: Nicht alle Bestätigungen/Abgaben sind erledigt.'); return; }

    let triggerCard=null;
    await db.runTransaction(async (t)=>{
      const doc = await t.get(roomRef);
      const g = doc.data().gameState;
      if(g.discardPile.length===0) return;
      const cardToReveal = g.discardPile.shift();
      g.revealedDiscard.push(cardToReveal);
      triggerCard = cardToReveal;
      g.currentTrigger = triggerCard;
      g.currentRow = null;
      g.currentPoints = 1; 
      g.giversDone = [];
      g.requiredGivers = [];
      t.update(roomRef,{ gameState: g });
    });
    if(triggerCard){
      await awardRowPointsOnReveal(triggerCard);
      await computeRequiredGivers(triggerCard);
    }
  }catch(e){ console.error(e); alert('Reststapel-Karte konnte nicht aufgedeckt werden: '+e.message); }
}

/* ================== ACTIONS ================== */
async function giveCard(){
    const assignmentArea = document.getElementById('card-assignment-area');
    const selects = assignmentArea.querySelectorAll('select');

    const assignments = {};
    const allCardsToGive = [];
    selects.forEach(select => {
        const card = select.dataset.card;
        const target = select.value;
        if (target) {
            if (!assignments[target]) assignments[target] = [];
            assignments[target].push(card);
            allCardsToGive.push(card);
        }
    });

    if (allCardsToGive.length === 0) {
        alert('Bitte weise mindestens eine Karte einem Spieler zu.');
        return;
    }

    try {
        await db.runTransaction(async (t) => {
            const roomRef = db.collection('rooms').doc(currentRoomCode);
            const sourceRef = roomRef.collection('players').doc(myNickname);

            const roomDoc = await t.get(roomRef);
            const sourceDoc = await t.get(sourceRef);

            const targetRefs = {};
            const targetDocs = {};
            for (const targetPlayer in assignments) {
                targetRefs[targetPlayer] = roomRef.collection('players').doc(targetPlayer);
                targetDocs[targetPlayer] = await t.get(targetRefs[targetPlayer]);
            }

            const gs = roomDoc.data().gameState || {};
            const requiredGivers = gs.requiredGivers || [];
            const giversDone = gs.giversDone || [];
            if (requiredGivers.includes(myNickname) && giversDone.includes(myNickname)) throw new Error('Du hast für diesen Buchstaben bereits abgegeben.');

            const sourceHand = sourceDoc.data().hand;
            for (const card of allCardsToGive) {
                if (!sourceHand.includes(card)) throw new Error(`Karte ${card} ist nicht mehr in deiner Hand.`);
            }

            const finalSourceHand = sourceHand.filter(c => !allCardsToGive.includes(c));
            t.update(sourceRef, { hand: finalSourceHand });

            for (const targetPlayer in assignments) {
                const cardsForThisPlayer = assignments[targetPlayer];
                const targetData = targetDocs[targetPlayer].data();
                const targetReceived = targetData.receivedCards || [];

                const rowPts = Number(gs.currentPoints) || 1;
                const pointsToAdd = rowPts * cardsForThisPlayer.length;
                const newScore = (Number(targetData.score) || 0) + pointsToAdd;

                t.update(targetRefs[targetPlayer], {
                    receivedCards: [...targetReceived, ...cardsForThisPlayer],
                    lastReceived: cardsForThisPlayer,
                    actionConfirmed: false,
                    score: newScore
                });
            }

            const newGiversDone = giversDone.includes(myNickname) ? giversDone : [...giversDone, myNickname];
            t.update(roomRef, { 'gameState.giversDone': newGiversDone });
        });

        document.getElementById('give-card-controls').style.display = 'none';
        await checkTriggerResolved();
    } catch (e) {
        console.error(e);
        alert('Karten konnten nicht abgegeben werden: ' + e.message);
    }
}

async function confirmReceivedCard(){
  const playerRef = db.collection('rooms').doc(currentRoomCode).collection('players').doc(myNickname);
  try{
    await playerRef.update({ actionConfirmed:true, lastReceived: firebase.firestore.FieldValue.delete() });
    document.getElementById('card-received-overlay').style.display='none';
    await checkTriggerResolved();
  }catch(e){ console.error(e); alert('Bestätigung fehlgeschlagen: '+e.message); }
}

/* ================== LISTENERS / UI ================== */
function setupLobbyListeners(roomCode){
  let unsubscribePlayers = db.collection('rooms').doc(roomCode).collection('players').onSnapshot(snap=>{
    currentPlayersInGame = snap.docs.map(doc=>doc.id);
    updatePlayerListUI(currentPlayersInGame);
    if(isHost) document.getElementById('start-game-button').disabled = currentPlayersInGame.length<2;
  });
  unsubscribeRoom = db.collection('rooms').doc(roomCode).onSnapshot(doc=>{
    const data = doc.data(); if(!data) return;
    if(data.status==='in-game'){
      if(unsubscribePlayers) unsubscribePlayers(); if(unsubscribeRoom) unsubscribeRoom();
      document.getElementById('game-player-list').innerHTML = document.getElementById('player-list').innerHTML;
      showScreen('game-screen');
      setupGameListeners(roomCode);
      updateGamePlayerScores(roomCode);
      return;
    }
    if(isHost){
      const area = document.getElementById('display-code-area');
      if(data.externalDisplayEnabled && data.displayCode){
        document.getElementById('display-code-display').innerText = data.displayCode; area.style.display='block';
      }else area.style.display='none';
    }else{
      document.getElementById('player-settings-display').innerHTML = `<p><strong>Einstellungen:</strong> ${data.settings.cardCount} Karten, ${data.settings.rowCount} Reihen. Display: ${data.externalDisplayEnabled?'Ja':'Nein'}</p>`;
    }
  });
}

function setupGameListeners(roomCode){
  if(isHost) document.getElementById('host-game-controls').style.display='block';
  unsubscribeMyHand = db.collection('rooms').doc(roomCode).collection('players').doc(myNickname).onSnapshot(doc=>{
    if(doc.exists){
      const p = doc.data();
      displayCards(p.hand||[],'hand-cards-display');
      const receivedArea = document.getElementById('received-cards');
      if(p.receivedCards && p.receivedCards.length>0){
        displayCards(p.receivedCards,'received-cards-display');
        receivedArea.style.display='block';
        
        if(!p.actionConfirmed && p.lastReceived && p.lastReceived.length > 0){
          const cardTexts = p.lastReceived.map(cardValueToText).join(', ');
          const cardPlural = p.lastReceived.length > 1 ? 'Karten' : 'Karte';
          
          document.querySelector('#card-received-overlay h2').innerText = `${cardPlural} erhalten!`;
          const pElement = document.querySelector('#card-received-overlay p');
          pElement.innerHTML = `Du hast die ${cardPlural.toLowerCase()} <strong id="received-card-value">${cardTexts}</strong> erhalten.`;
          
          document.getElementById('card-received-overlay').style.display='flex';
        }
      }else receivedArea.style.display='none';
    }
  });
  unsubscribeRoom = db.collection('rooms').doc(roomCode).onSnapshot(async doc=>{
    const data = doc.data(); if(!data || !data.gameState) return;
    const { pyramid, revealedDiscard, discardPile, currentTrigger, currentPoints, requiredGivers=[], giversDone=[] } = data.gameState;

    displayPyramid(pyramid,'pyramid-area-player',false);
    displayCards(revealedDiscard,'public-revealed-cards');

    const triggerRank = currentTrigger ? RANK_TEXT[currentTrigger.charAt(0)] : null;
    document.getElementById('active-trigger-player').innerText = triggerRank ? `${triggerRank} (${currentPoints || '-'} Pkt.)` : '–';

    if(isHost){
      const playersSnapshot = await db.collection('rooms').doc(roomCode).collection('players').get();
      const allConfirmed = playersSnapshot.docs.every(d=>d.data().actionConfirmed);
      const allGiversDone = requiredGivers.every(n=>giversDone.includes(n));
      document.getElementById('reveal-pyramid-card-button').style.display = data.externalDisplayEnabled ? 'none' : 'block';
      document.getElementById('reveal-pyramid-card-button').disabled = pyramid.every(c=>c.isRevealed) || !allConfirmed || !allGiversDone;
      document.getElementById('reveal-discard-card-button').disabled = discardPile.length===0 || !allConfirmed || !allGiversDone;
      document.getElementById('host-wait-hint').style.display = (allConfirmed && allGiversDone)?'none':'block';
    }

    const giveControls = document.getElementById('give-card-controls');
    if(triggerRank){
      const myHand = Array.from(document.querySelectorAll('#hand-cards-display .card')).map(c=>c.dataset.value);
      const playableCards = myHand.filter(c=>c.charAt(0)===currentTrigger.charAt(0));
      const mustGive = requiredGivers.includes(myNickname) && !giversDone.includes(myNickname);
      if(playableCards.length>0 && mustGive){
        const assignmentArea = document.getElementById('card-assignment-area');
        assignmentArea.innerHTML = '';
        const otherPlayers = currentPlayersInGame.filter(p => p !== myNickname);
        const playerOptions = '<option value="">- Spieler wählen -</option>' + otherPlayers.map(p => `<option value="${p}">${p}</option>`).join('');
        playableCards.forEach(card => {
            const row = document.createElement('div');
            row.className = 'card-assignment-row';
            const cardElHTML = createCardElement(card).outerHTML;
            row.innerHTML = `${cardElHTML}<select data-card="${card}">${playerOptions}</select>`;
            assignmentArea.appendChild(row);
        });
        giveControls.style.display='block';
      }else giveControls.style.display='none';

    }else giveControls.style.display='none';
  });
}

function setupDisplayListeners(roomCode){
  unsubscribeRoom = db.collection('rooms').doc(roomCode).onSnapshot(async doc=>{
    const data = doc.data();
    if(data && data.gameState){
      const { pyramid, revealedDiscard, currentTrigger, currentPoints, requiredGivers=[], giversDone=[] } = data.gameState;
      displayPyramid(pyramid,'pyramid-area-display',true);
      displayCards(revealedDiscard,'display-revealed-cards');

      const triggerRank = currentTrigger ? RANK_TEXT[currentTrigger.charAt(0)] : null;
      document.getElementById('active-trigger-display').innerText = triggerRank ? `${triggerRank} (${currentPoints || '-'} Pkt.)` : '–';

      const playersSnapshot = await db.collection('rooms').doc(roomCode).collection('players').get();
      const allConfirmed = playersSnapshot.docs.every(d=>d.data().actionConfirmed);
      const allGiversDone = requiredGivers.every(n=>giversDone.includes(n));
      document.querySelectorAll('#pyramid-area-display .card.interactive').forEach(cardEl=>{
        const ok = allConfirmed && allGiversDone;
        cardEl.style.pointerEvents = ok ? 'auto' : 'none';
        cardEl.style.opacity = ok ? '1' : '0.5';
      });
    }
  });
}

function updatePlayerListUI(players){
  const list = document.getElementById('player-list'); list.innerHTML='';
  players.forEach(name=>{
    const li = document.createElement('li');
    li.textContent = name + (name===myNickname?' (Du)':'');
    if(name===myNickname) li.style.fontWeight='bold';
    list.appendChild(li);
  });
  document.getElementById('player-count').innerText = players.length;
}

function updateGamePlayerScores(roomCode){
  const list = document.getElementById('game-player-list');
  db.collection('rooms').doc(roomCode).collection('players').onSnapshot(snap=>{
    const arr = snap.docs.map(d=>({ name:d.id, score:Number(d.data().score)||0 }));
    list.innerHTML = arr
      .sort((a,b)=> b.score-a.score || a.name.localeCompare(b.name))
      .map(p=>`<li>${p.name}${p.name===myNickname?' (Du)':''} — Punkte: <strong>${p.score}</strong></li>`)
      .join('');
  });
}

function displayCards(cards,id){
  const el=document.getElementById(id); el.innerHTML='';
  if(!cards||cards.length===0){ el.innerText='Keine'; return; }
  cards.sort((a,b)=>a.localeCompare(b,undefined,{numeric:true}));
  cards.forEach(card=>{
      el.appendChild(createCardElement(card));
  });
}

function displayPyramid(pyramidData, containerId, isInteractive){
  const container = document.getElementById(containerId); container.innerHTML='';
  if(!pyramidData || pyramidData.length===0) return;
  const totalRows = getTotalRows(pyramidData);
  let pos=0;
  for(let row=1; row<=totalRows; row++){
    const rowEl=document.createElement('div'); rowEl.className='pyramid-row';
    for(let i=0;i<row;i++){
      const cardData = pyramidData[pos];
      const isRevealed = cardData.isRevealed;
      const cardEl = createCardElement(cardData.cardValue, !isRevealed);
      cardEl.dataset.index = pos;

      if(!isRevealed && isInteractive){
          cardEl.classList.add('interactive');
          cardEl.onclick = () => revealPyramidCard(cardEl.dataset.index);
      }
      rowEl.appendChild(cardEl);
      pos++;
    }
    container.appendChild(rowEl);
  }
}

function indexToRow(pyramidData, idx){
  let row=1, used=0;
  while(true){
    if(idx < used+row) return row;
    used += row; row++;
  }
}

async function computeRequiredGivers(triggerCard){
  const roomRef = db.collection('rooms').doc(currentRoomCode);
  const rank = String(triggerCard).charAt(0);
  try{
    const playersSnapshot = await roomRef.collection('players').get();
    const required = playersSnapshot.docs
      .filter(d=>Array.isArray(d.data().hand) && d.data().hand.some(c=>String(c).charAt(0)===rank))
      .map(d=>d.id);
    await roomRef.update({ 'gameState.requiredGivers': required, 'gameState.giversDone': [] });
  }catch(e){ console.error('computeRequiredGivers error', e); }
}

async function awardRowPointsOnReveal(triggerCard){
  const roomRef = db.collection('rooms').doc(currentRoomCode);
  const rank = String(triggerCard).charAt(0);
  const roomDoc = await roomRef.get();
  const gs = roomDoc.data().gameState||{};
  const pts = Number(gs.currentPoints)||1;
  if(!pts) return;
  const playersSnapshot = await roomRef.collection('players').get();
  const updates = [];
  for(const d of playersSnapshot.docs){
    const data = d.data();
    const received = Array.isArray(data.receivedCards) ? data.receivedCards : [];
    const matches = received.filter(c=>String(c).charAt(0)===rank).length;
    if(matches>0){
      const newScore = (Number(data.score)||0) + matches*pts;
      updates.push(roomRef.collection('players').doc(d.id).update({ score: newScore }));
    }
  }
  await Promise.all(updates);
}

async function checkTriggerResolved(){
  const roomRef = db.collection('rooms').doc(currentRoomCode);
  try{
    const roomDoc = await roomRef.get();
    const gs = roomDoc.data().gameState||{};
    const required = gs.requiredGivers||[];
    const done = gs.giversDone||[];
    const playersSnapshot = await roomRef.collection('players').get();
    const allConfirmed = playersSnapshot.docs.every(d=>d.data().actionConfirmed);
    const allGiversDone = required.every(n=>done.includes(n));
    if(gs.currentTrigger && allConfirmed && allGiversDone){
      await roomRef.update({
        'gameState.currentTrigger': null,
        'gameState.currentRow': null,
        'gameState.currentPoints': null,
        'gameState.requiredGivers': [],
        'gameState.giversDone': []
      });
    }
  }catch(e){ console.error('checkTriggerResolved error', e); }
}
</script>
</body>
</html>
